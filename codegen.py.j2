import functools
import typing

import lxml.etree

import binding_util

class Element:
    """
    Base class for a Element wrapper around an lxml element.
    """
    def __init__(self, element: lxml.etree._Element):
        self._element = element


# -----------------
# Data classes
# -----------------
{% for data in data_definitions %}
class {{ data.class_name }}(Element):
    """
    Wrapper for the `<{{ data.tag_name }}>` data element.
    """
    TAG = "{{ data.tag_name }}"
    """Tag name for the `<{{ data.tag_name }}>` element."""
{% if data.simple_members %}
{% for member in data.simple_members %}
    TAG_{{ member.prop_name.upper() }} = "{{ member.tag_name }}"
    """Tag name for the simple member `<{{ member.tag_name }}>`."""
{% endfor %}
{% endif %}
{% if data.child_datadefs %}
{% for sub in data.child_datadefs %}
    TAG_{{ sub.prop_name.upper() }} = "{{ sub.tag_name }}"
{% endfor %}
{% endif %}

{% if data.simple_members %}
    # Simple member properties
{% for member in data.simple_members %}
    @binding_util.cached_property
    def {{ member.prop_name }}(self) -> {{ member.py_type }}:
        """Gets the value of the <{{ member.tag_name }}> child element."""
        elem = self._element.find(self.TAG_{{ member.prop_name.upper() }})
        if elem is None or elem.text is None:
            raise AttributeError(f"Missing element (or empty) '{self.TAG_{{ member.prop_name.upper() }}}' in {self.TAG}")
        return {{ member.py_type }}(elem.text)

    @{{ member.prop_name }}.setter
    def {{ member.prop_name }}(self, value: {{ member.py_type }}):
        elem = self._element.find(self.TAG_{{ member.prop_name.upper() }})
        if elem is None:
            raise AttributeError(f"Missing element '{self.TAG_{{ member.prop_name.upper() }}}' in {self.TAG}")
        elem.text = str(value)
{% endfor %}
{% endif %}

{% if data.child_datadefs %}
    # Sub-child_datadefs accessors
{% for sub in data.child_datadefs %}
    @property
    def {{ sub.prop_name }}(self) -> typing.Optional[{{ sub.class_name }}]:
        elem = self._element.find(self.TAG_{{ sub.prop_name.upper() }})
        if elem is None:
            raise AttributeError(f"Missing element '{self.TAG_{{ sub.prop_name.upper() }}}' in {self.TAG}")
        return {{ sub.class_name }}(elem)

{% endfor %}
{% endif %}

{% if not data.simple_members and not data.child_datadefs %}
    pass
{% endif %}

{% endfor %}

# -----------------
# Component classes (wrap a `<component>` element with a specific `type`)
# -----------------
{% for comp in component_definitions %}
class {{ comp.class_name }}(Element):
    """
    Wrapper for a `<component type="{{ comp.variant }}">` element.
    """
    TAG = "{{ comp.tag_name }}"
    """Tag name for the `<{{ comp.tag_name }}>` element."""
{% if comp.simple_members %}
{% for member in comp.simple_members %}
    TAG_{{ member.prop_name.upper() }} = "{{ member.tag_name }}"
    """Tag name for the simple member `<{{ member.tag_name }}>`."""
{% endfor %}
{% endif %}
{% if comp.child_datadefs %}
{% for sub in comp.child_datadefs %}
    TAG_{{ sub.prop_name.upper() }} = "{{ sub.tag_name }}"
{% endfor %}
{% endif %}

{% if comp.child_datadefs %}
    # Sub-child_datadefs accessors
{% for sub in comp.child_datadefs %}
    @property
    def {{ sub.prop_name }}(self) -> typing.Optional[{{ sub.class_name }}]:
        elem = self._element.find(self.TAG_{{ sub.prop_name.upper() }})
        if elem is None:
            raise AttributeError(f"Missing element '{self.TAG_{{ sub.prop_name.upper() }}}' in {self.TAG}")
        return {{ sub.class_name }}(elem)

{% endfor %}
{% endif %}
{% if not comp.child_datadefs %}
    pass
{% endif %}

{% endfor %}


# -----------------
# Entity wrapper
# -----------------
{% if entity %}
class Entity(Element):
    """Wrapper for `<entitytag>` elements."""
{% if entity.simple_members %}
{% for member in entity.simple_members.values() %}
    TAG_{{ member.prop_name.upper() }} = "{{ member.tag_name }}"
    """Tag name for the simple member `<{{ member.tag_name }}>`."""
{% endfor %}
{% endif %}

{% if entity.simple_members %}
    # Simple member properties
{% for member in entity.simple_members.values() %}
    @binding_util.cached_property
    def {{ member.prop_name }}(self) -> {{ member.py_type }}:
        """Gets the value of the <{{ member.tag_name }}> child element."""
        elem = self._element.find(self.TAG_{{ member.prop_name.upper() }})
        if elem is None or elem.text is None:
            raise AttributeError(f"Missing element (or empty) '{self.TAG_{{ member.prop_name.upper() }}}' in {self.TAG}")
        return {{ member.py_type }}(elem.text)

    @{{ member.prop_name }}.setter
    def {{ member.prop_name }}(self, value: {{ member.py_type }}):
        elem = self._element.find(self.TAG_{{ member.prop_name.upper() }})
        if elem is None:
            raise AttributeError(f"Missing element '{self.TAG_{{ member.prop_name.upper() }}}' in {self.TAG}")
        elem.text = str(value)

{% endfor %}
{% endif %}

    def __getattr__(self, name: str):
        """
        Dynamically look up component variants by name.
        E.g., entity.comp1 returns the <component type="comp1"> wrapper or None.
        """
        # Check if this name is a known component variant
        if name in COMPONENT_VARIANT_MAP:
            variant_class = COMPONENT_VARIANT_MAP[name]
            for c in self._element.findall("component"):
                if c.get("type") == name:
                    return variant_class(c)
            return None
        # Fall back to default behavior
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

{% endif %}


# -----------------
# Runtime helper maps
# -----------------
# Map data tag names to their wrapper classes
DATA_TAG_TO_CLASS_MAP = {
{% for data in data_definitions %}
    {{ data.class_name }}.TAG: {{ data.class_name }},
{% endfor %}
}

# Map component variant names to the component wrapper classes
COMPONENT_VARIANT_MAP = {
{% for comp in component_definitions %}
    "{{ comp.variant }}": {{ comp.class_name }},
{% endfor %}
}

# Map simple element tag names to Python types
SIMPLE_TYPE_MAP = {
{% for name, py_type in simple_type_map.items() %}
    "{{ name }}": {{ py_type }},
{% endfor %}
}
