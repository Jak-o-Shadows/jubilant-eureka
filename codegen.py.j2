import functools
import typing

import lxml.etree


class Element:
    """
    Base class for a Element wrapper around an lxml element.
    """
    def __init__(self, element: lxml.etree._Element):
        self._element = element

# Late import to avoid circular dependency: binding_util.File -> generated_bindings -> binding_util.cached_property
import binding_util


# -----------------
# Data classes
# -----------------
{% for data in data_definitions %}
class {{ data.class_name }}(Element):
    """
    Wrapper for the `<{{ data.tag_name }}>` data element.
    """
{% if data.simple_members %}
    # Simple member properties
{% for member in data.simple_members %}
    @binding_util.cached_property
    def {{ member.prop_name }}(self) -> typing.Optional[{{ member.py_type }}]:
        """Gets the value of the <{{ member.tag_name }}> child element."""
        elem = self._element.find("{{ member.tag_name }}")
        if elem is None or elem.text is None:
            return None
        return {{ member.py_type }}(elem.text)

    @{{ member.prop_name }}.setter
    def {{ member.prop_name }}(self, value: {{ member.py_type }}):
        elem = self._element.find("{{ member.tag_name }}")
        if elem is None:
            raise AttributeError("Missing element '{{ member.tag_name }}' in {{ data.tag_name }}")
        elem.text = str(value)

{% endfor %}
{% endif %}
{% if data.sub_components %}
    # Sub-component accessors
{% for sub in data.sub_components %}
    @property
    def {{ sub.prop_name }}(self) -> typing.Optional[{{ sub.class_name }}]:
        elem = self._element.find("{{ sub.tag_name }}")
        if elem is None:
            return None
        return {{ sub.class_name }}(elem)

{% endfor %}
{% endif %}
{% if not data.simple_members and not data.sub_components %}
    pass
{% endif %}

{% endfor %}


# -----------------
# Component classes (wrap a `<component>` element with a specific `type`)
# -----------------
{% for comp in component_definitions %}
class {{ comp.class_name }}(Element):
    """
    Wrapper for a `<component type="{{ comp.variant }}">` element.
    """
{% if comp.simple_members %}
    # Simple members directly inside the component
{% for member in comp.simple_members %}
    @binding_util.cached_property
    def {{ member.prop_name }}(self) -> typing.Optional[{{ member.py_type }}]:
        elem = self._element.find("{{ member.tag_name }}")
        if elem is None or elem.text is None:
            return None
        return {{ member.py_type }}(elem.text)

    @{{ member.prop_name }}.setter
    def {{ member.prop_name }}(self, value: {{ member.py_type }}):
        elem = self._element.find("{{ member.tag_name }}")
        if elem is None:
            raise AttributeError("Missing element '{{ member.tag_name }}' in component {{ comp.variant }}")
        elem.text = str(value)

{% endfor %}
{% endif %}
{% if comp.sub_components %}
    # Sub-components referenced by this component (these are data-type child tags)
{% for sub in comp.sub_components %}
    @property
    def {{ sub.prop_name }}(self) -> typing.Optional[{{ sub.class_name }}]:
        elem = self._element.find("{{ sub.tag_name }}")
        if elem is None:
            return None
        return {{ sub.class_name }}(elem)

{% endfor %}
{% endif %}
{% if not comp.simple_members and not comp.sub_components %}
    pass
{% endif %}

{% endfor %}


# -----------------
# Entity wrapper
# -----------------
{% if entity %}
class {{ entity.class_name }}(Element):
    """Wrapper for `<entitytag>` elements."""

{% for child in entity.simple_children %}
    @property
    def {{ child }}(self) -> typing.Optional[typing.Any]:
        elem = self._element.find("{{ child }}")
        if elem is None or elem.text is None:
            return None
        py_type = SIMPLE_TYPE_MAP.get("{{ child }}")
        if py_type is None:
            return elem.text
        return py_type(elem.text)

{% endfor %}
    def __getattr__(self, name: str):
        """
        Dynamically look up component variants by name.
        E.g., entity.comp1 returns the <component type="comp1"> wrapper or None.
        """
        # Check if this name is a known component variant
        if name in COMPONENT_VARIANT_MAP:
            variant_class = COMPONENT_VARIANT_MAP[name]
            for c in self._element.findall("component"):
                if c.get("type") == name:
                    return variant_class(c)
            return None
        # Fall back to default behavior
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")

{% endif %}


# -----------------
# Runtime helper maps
# -----------------
# Map data tag names to their wrapper classes
DATA_TAG_TO_CLASS_MAP = {
{% for data in data_definitions %}
    "{{ data.tag_name }}": {{ data.class_name }},
{% endfor %}
}

# Map component variant names to the component wrapper classes
COMPONENT_VARIANT_MAP = {
{% for comp in component_definitions %}
    "{{ comp.variant }}": {{ comp.class_name }},
{% endfor %}
}

# Map simple element tag names to Python types
SIMPLE_TYPE_MAP = {
{% for name, py_type in simple_type_map.items() %}
    "{{ name }}": {{ py_type }},
{% endfor %}
}
